package sinchronizeExample;

/*
* Объект синхронизации CyclicBarrier представляет собой барьерную синхронизацию, используемую, как правило, в распределённых
* вычислениях. Особенно эффективно использование барьеров при циклических расчетах. При барьерной синхронизации алгоритм
* расчета делят на несколько потоков. С помощью барьера организуют точку сбора частичных результатов вычислений, в которой подводится итог этапа вычислений.

В исходном коде барьер для группы потоков означает, что каждый поток должен остановиться в определенном месте и ожидать
* прихода остальных потоков группы. Как только все потоки достигнут барьера, их выполнение продолжится.

Класс CyclicBarrier имеет 2 конструктора :

CyclicBarrier(int count);
CyclicBarrier(int count, Runnable class);
В первом конструкторе задается количество потоков, которые должны достигнуть барьера, чтобы после этого одновременно
* продолжить выполнение кода. Во втором конструкторе дополнительно задается реализующий интерфейс Runnable класс,
* который должен быть запущен после прихода к барьеру всех потоков. Поток запускать самостоятельно НЕ НУЖНО. CyclicBarrier это делает автоматически.

Для указания потоку о достижении барьера нужно вызвать один из перегруженных методов await :

void await() throws InterruptedException
boolean await(long wait, TimeUnit unit) throws InterruptedException;
Назначение параметров wait и unit у второго метода описано выше (см. CountDownLatch).

Циклический барьер CyclicBarrier похож на CountDownLatch. Главное различие между ними связано с тем, что «защелку»
* нельзя использовать повторно после того, как её счётчик обнулится, а барьер можно использовать (в цикле).
* С точки зрения API циклический барьер CyclicBarrier имеет только метод самоблокировки await и не имеет метода
* декрементации счетчика, а также позволяет подключить и автоматически запускать дополнительный потоковый класс при достижении барьера всех исполняемых потоков.
* */

/*
В примере организуется переправа. Паром может вместить только 3 автомобиля. Количество автомобилей 9.
Роль парома выполняет объект синхронизации FerryBarrier, которому в качестве второго параметра передается
реализующий интерфейс Runnable класс FerryBoat. Как только 3 потока достигнут барьера автоматически будет запущен
FerryBoat, после завершения работы которого потоки продолжают свою работу.
* */

/*
* Потоки подходят к барьеру с интервалом в 400 ms. Время задержки у барьера/переправы
* (после того, как собралось необходимое количество потоков), составляет 500 ms, если не считать время вывода
* сообщений в консоль. За это время к барьеру успевает подойти еще один поток. Что мы и видим при выводе сообщений в консоль.
* */

import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {

  private static CyclicBarrier FerryBarrier;
  private static final int FerryBoat_size = 3;

  // Переправляющий автомобили паром
  public static class FerryBoat implements Runnable {

    @Override
    public void run() {
      try {
        // Задержка на переправе
        System.out.println(
            "\nЗагрузка автомобилей");
        Thread.sleep(500);
        System.out.println(
            "Паром переправил автомобили\n");
      } catch (InterruptedException e) {
      }
    }
  }

  // Класс автомобиля
  public static class Car implements Runnable {

    private int carNumber;

    public Car(int carNumber) {
      this.carNumber = carNumber;
    }

    @Override
    public void run() {
      try {
        System.out.println("К переправе подъехал автомобиль " + carNumber);
        // Вызов метода await при подходе к
        // барьеру; поток блокируется в ожидании
        // прихода остальных потоков
        FerryBarrier.await();
        System.out.println("Автомобиль " + carNumber + " продолжил движение");
      } catch (Exception e) {
      }
    }
  }

  public static void main(String[] args) throws InterruptedException {
    FerryBarrier = new CyclicBarrier(FerryBoat_size,
        new FerryBoat());
    for (int i = 0; i < 9; i++) {
      new Thread(new Car(i)).start();
      Thread.sleep(400);
    }
  }
}
